# User Story: Implementa√ß√£o de Seguran√ßa H√≠brida (Basic Auth para Webhook)

**T√≠tulo:** Configura√ß√£o de Cadeia de Seguran√ßa Secund√°ria para Webhook (US-06)
**Contexto:** O microsservi√ßo j√° protege a rota de carga (`/integracao`) com OAuth2/JWT. Agora, implementamos o endpoint do Webhook do Twilio (`/webhook`). Como o Twilio n√£o realiza fluxo de login OAuth2 para pegar tokens, precisamos proteger esta rota espec√≠fica com **Basic Auth** (Usu√°rio e Senha), mantendo o restante da aplica√ß√£o segura via JWT.

## üìù Descri√ß√£o da Hist√≥ria
**Como** Arquiteto de Seguran√ßa,
**Quero** configurar uma estrat√©gia de *Multiple Security Filter Chains* no Spring Security,
**Para que** o endpoint `/api/v1/webhook/**` seja acess√≠vel apenas via Basic Authentication, enquanto o endpoint `/api/v1/integracao/**` continua exigindo Token JWT, sem conflitos entre eles.

---

## ‚öôÔ∏è Especifica√ß√µes T√©cnicas (Constraints)

1.  **M√∫ltiplos Filter Chains:**
    *   O Spring Security 6 permite definir m√∫ltiplos Beans do tipo `SecurityFilterChain`.
    *   Deve-se utilizar a anota√ß√£o `@Order` para garantir que a cadeia do Webhook seja avaliada antes da cadeia padr√£o/JWT.
    *   **Cadeia 1 (Webhook):** Matcher `/api/v1/webhook/**`, `@Order(1)`, Auth Type: `httpBasic()`.
    *   **Cadeia 2 (Padr√£o):** Matcher `anyRequest()` ou `/api/v1/integracao/**`, Auth Type: `oauth2ResourceServer()`.
2.  **Gerenciamento de Usu√°rios (In-Memory):**
    *   Para o Webhook, n√£o precisamos de banco de dados.
    *   Utilizar `InMemoryUserDetailsManager`.
    *   O usu√°rio e senha devem ser injetados via `application.yml` (ex: `webhook-user` / `webhook-pass`), permitindo inje√ß√£o via vari√°veis de ambiente no Docker.
3.  **Stateless:**
    *   Ambas as cadeias devem manter a pol√≠tica de sess√£o como `STATELESS` e CSRF desabilitado.

---

## ‚úÖ Crit√©rios de Aceite (Acceptance Criteria)

### 1. Isolamento de Seguran√ßa
*   Tentar acessar `/api/v1/webhook/twilio` sem credenciais deve retornar **401 Unauthorized** (com header `WWW-Authenticate: Basic`).
*   Tentar acessar `/api/v1/integracao/agendamentos` com Basic Auth deve falhar (**401**).

### 2. Autentica√ß√£o Basic com Sucesso
*   Acessar o Webhook enviando o header `Authorization: Basic <base64(user:pass)>` correto deve retornar **200 OK**.

### 3. Preserva√ß√£o do OAuth2
*   A implementa√ß√£o n√£o pode quebrar a autentica√ß√£o JWT existente na rota de integra√ß√£o. O token do Keycloak deve continuar funcionando normalmente.

### 4. Configura√ß√£o Externalizada
*   N√£o "hardcodar" a senha no c√≥digo Java. Ela deve vir de uma propriedade `@Value` ou `ConfigurationProperties`.

---

## üíª Solicita√ß√£o de C√≥digo

Com base nas especifica√ß√µes acima, gere:

1.  **Atualiza√ß√£o do SecurityConfig.java**:
    *   Reescreva a classe para conter **dois** m√©todos `@Bean` que retornam `SecurityFilterChain`.
    *   O primeiro bean deve focar em `/api/v1/webhook/**`, ter `@Order(1)` e usar `.httpBasic()`.
    *   O segundo bean deve tratar o restante das requisi√ß√µes com `.oauth2ResourceServer()`.
2.  **Bean UserDetailsService**:
    *   Crie um `@Bean` que retorna `InMemoryUserDetailsManager` com um usu√°rio criado a partir de vari√°veis do `application.yml`.
3.  **Atualiza√ß√£o do application.yml**:
    *   Adicione as chaves `sus.security.webhook.username` e `sus.security.webhook.password` (com valores default para desenvolvimento, ex: `twilio` / `teste123`).
4.  **Ajuste no WebhookController (Opcional)**:
    *   Se houver alguma anota√ß√£o de seguran√ßa espec√≠fica na classe, garanta que ela n√£o conflite, ou remova `@PreAuthorize` desta rota espec√≠fica, confiando no filtro HTTP.