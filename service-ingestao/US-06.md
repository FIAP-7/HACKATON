# User Story: Containeriza√ß√£o Otimizada e Documenta√ß√£o OpenAPI (US-07)

**T√≠tulo:** Dockeriza√ß√£o e Documenta√ß√£o com Swagger UI (US-07)
**Contexto:** O microsservi√ßo est√° funcional e seguro. Agora, precisamos empacot√°-lo para rodar no ambiente orquestrado (Docker Compose) e fornecer uma interface visual para que os desenvolvedores (e os avaliadores do Hackathon) possam testar os endpoints sem precisar decorar comandos cURL.

## üìù Descri√ß√£o da Hist√≥ria
**Como** DevOps / Desenvolvedor,
**Quero** empacotar a aplica√ß√£o em uma imagem Docker otimizada e expor a documenta√ß√£o via Swagger UI,
**Para que** o deploy seja consistente em qualquer ambiente e a integra√ß√£o com o servi√ßo seja facilitada.

---

## ‚öôÔ∏è Especifica√ß√µes T√©cnicas (Constraints)

1.  **Containeriza√ß√£o (Docker):**
    *   Utilizar **Multi-Stage Build**:
        *   *Stage 1 (Build):* Imagem Maven com JDK 21 para compilar o projeto.
        *   *Stage 2 (Run):* Imagem JRE leve (ex: `eclipse-temurin:21-jre-alpine`) apenas para execu√ß√£o.
    *   Expor a porta 8080.
2.  **Observabilidade B√°sica (Health Check):**
    *   Adicionar **Spring Boot Actuator**.
    *   Expor o endpoint `/actuator/health`.
    *   Configurar o `docker-compose.yml` para usar esse endpoint como verifica√ß√£o de sa√∫de (`healthcheck`).
3.  **Documenta√ß√£o (OpenAPI 3.0):**
    *   Utilizar `springdoc-openapi-starter-webmvc-ui`.
    *   **Desafio de Seguran√ßa:** A documenta√ß√£o deve refletir a nossa seguran√ßa h√≠brida.
        *   Deve permitir testar a rota `/integracao` inserindo um **Bearer Token**.
        *   Deve permitir testar a rota `/webhook` inserindo credenciais **Basic Auth**.

---

## ‚úÖ Crit√©rios de Aceite (Acceptance Criteria)

### 1. Imagem Docker Funcional
*   O comando `docker build -t ms-ingestao .` deve criar uma imagem com tamanho reduzido (apenas JRE, sem Maven).
*   O container deve subir sem erros e conectar no RabbitMQ.

### 2. Swagger UI Acess√≠vel
*   Acessar `http://localhost:8080/swagger-ui.html` (ou `/swagger-ui/index.html`) deve carregar a interface visual.
*   O Swagger deve exibir os dois Controllers (`AgendamentoController` e `WebhookController`).

### 3. Defini√ß√£o de Seguran√ßa no Swagger
*   O bot√£o "Authorize" no Swagger deve oferecer duas op√ß√µes:
    1.  `bearerAuth` (HTTP Bearer JWT).
    2.  `basicAuth` (HTTP Basic).
*   Os endpoints devem estar anotados com `@SecurityRequirement` indicando qual esquema usam (ex: Webhook usa Basic, Integracao usa Bearer).

### 4. Health Check
*   A requisi√ß√£o `GET /actuator/health` deve retornar `{"status": "UP"}`.

---

## üíª Solicita√ß√£o de C√≥digo

Com base nas especifica√ß√µes acima, gere:

1.  **Atualiza√ß√£o do pom.xml**: Adicione `spring-boot-starter-actuator` e `springdoc-openapi-starter-webmvc-ui`.
2.  **OpenApiConfig.java**: Classe de configura√ß√£o que define os componentes de seguran√ßa (`SecurityScheme`) do OpenAPI:
    *   Scheme "bearerAuth" (Type: HTTP, Scheme: bearer, Format: JWT).
    *   Scheme "basicAuth" (Type: HTTP, Scheme: basic).
3.  **Anota√ß√µes nos Controllers**:
    *   Adicione `@Operation(security = @SecurityRequirement(name = "bearerAuth"))` no `AgendamentoController`.
    *   Adicione `@Operation(security = @SecurityRequirement(name = "basicAuth"))` no `WebhookController`.
4.  **Dockerfile**: O arquivo com multi-stage build para Java 21.
5.  **Atualiza√ß√£o do application.yml**:
    *   Exponha o actuator: `management.endpoints.web.exposure.include=health,info`.
6.  **Atualiza√ß√£o do docker-compose.yml**:
    *   Configure o servi√ßo `ms-ingestao` para fazer o build a partir do Dockerfile local.
    *   Adicione a se√ß√£o `healthcheck` apontando para o actuator.