# User Story: Implementa√ß√£o do Producer RabbitMQ e Configura√ß√£o de Mensageria

**T√≠tulo:** Configura√ß√£o do Broker e Implementa√ß√£o do Producer (US-02)
**Contexto:** J√° possu√≠mos a API que recebe e valida os dados (US-01). Agora, precisamos persistir esses dados de forma ass√≠ncrona em uma fila, garantindo que o `ms-ingestao` n√£o trave se o processamento for lento.

## üìù Descri√ß√£o da Hist√≥ria
**Como** Microsservi√ßo de Ingest√£o,
**Quero** transformar a requisi√ß√£o validada em um evento JSON e public√°-lo em uma Exchange no RabbitMQ,
**Para que** o Microsservi√ßo de Processamento possa consumir esses dados posteriormente, garantindo alta disponibilidade e desacoplamento.

---

## ‚öôÔ∏è Especifica√ß√µes T√©cnicas (Constraints)

1.  **Arquitetura (Port & Adapter):**
    *   O **Core Domain** (Service) n√£o deve depender da biblioteca `amqp`.
    *   Deve-se criar uma **Interface (Porta de Sa√≠da)** no pacote `core` (ex: `AgendamentoPublisherPort`).
    *   A implementa√ß√£o concreta (**Adapter**) deve ficar no pacote `infra` e utilizar o `RabbitTemplate`.
2.  **Serializa√ß√£o:**
    *   N√£o utilizar serializa√ß√£o nativa do Java. As mensagens devem trafegar como **JSON**.
    *   Configurar o Bean `Jackson2JsonMessageConverter`.
3.  **Topologia RabbitMQ:**
    *   A aplica√ß√£o deve declarar automaticamente a infraestrutura (Exchange, Queue e Binding) ao iniciar, para facilitar o setup do ambiente de desenvolvimento.

---

## ‚úÖ Crit√©rios de Aceite (Acceptance Criteria)

### 1. Defini√ß√£o da Topologia (Configuration)
*   Criar uma classe de configura√ß√£o (`RabbitMqConfig`) que defina:
    *   **Exchange:** `sus.direct.exchange` (Tipo: Direct, Dur√°vel).
    *   **Queue:** `sus.input.carga-agendamento` (Dur√°vel).
    *   **Routing Key:** `rota.carga.agendamento`.
    *   **Binding:** Ligar a Queue na Exchange usando a Routing Key.

### 2. Convers√£o de Mensagem (JSON)
*   Configurar o `RabbitTemplate` para usar o `Jackson2JsonMessageConverter`.
*   A mensagem na fila deve ser leg√≠vel (texto JSON), contendo os dados do agendamento e um timestamp de ingest√£o.

### 3. Implementa√ß√£o do Adapter
*   Criar a classe `RabbitMqAgendamentoProducer` que implementa a porta de sa√≠da definida no Core.
*   Esta classe deve injetar o `RabbitTemplate` e realizar o envio (`convertAndSend`).

### 4. Integra√ß√£o com o Service
*   Atualizar o `IngestaoService` (criado na US-01) para injetar a interface `AgendamentoPublisherPort`.
*   Ap√≥s a valida√ß√£o, o Service deve chamar o m√©todo de publica√ß√£o.

---

## üíª Solicita√ß√£o de C√≥digo

Com base nas especifica√ß√µes acima, gere:

1.  **RabbitMqConfig.java**: Classe com a defini√ß√£o dos Beans (Queue, DirectExchange, Binding e MessageConverter).
2.  **AgendamentoEvent.java**: Um novo Record no pacote `core` para representar o evento que vai para a fila (pode ser id√™ntico ao DTO de entrada, mas com adi√ß√£o de um campo `dataIngestao`).
3.  **AgendamentoPublisherPort.java**: Interface no pacote `core` definindo o contrato de envio.
4.  **RabbitMqAgendamentoProducer.java**: Implementa√ß√£o no pacote `infra` usando `RabbitTemplate`.
5.  **Atualiza√ß√£o do Service**: Modifique a classe de servi√ßo existente para usar a porta e enviar a mensagem.
6.  **Docker Compose Update**: Adicione o servi√ßo do RabbitMQ (imagem `rabbitmq:3-management`) no `docker-compose.yml` e as vari√°veis de conex√£o no `application.yml`.